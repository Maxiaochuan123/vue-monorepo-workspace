# 🛸 Monorepo 架构演进：深度对话与思维实录

这份文档记录了我们在搭建此项目过程中，关于 Monorepo 架构最核心的讨论与思维碰撞，旨在帮助团队新成员快速理解为什么我们选择了这种模式，以及它是如何运行的。

---

## 阶段一：初识——打破“每一个包都要部署”的直觉

### ❓ 困惑：多项目并存的发布焦虑

> “如果我把所有项目都放在 packages 下，那部署的时候岂不是全都要发一遍？而且域名都不一样，我怎么访问？难道共享包（shared）也要有自己的服务器吗？”

### 💡 架构真相：前端的“合体”逻辑

- **核心逻辑**：在前端工程中，共享包（shared）是**“源代码库”**，而不是**“微服务”**。
- **构建（Build）**：Vite 在打包 `app` 或 `app2` 时，会将 `shared` 中被用到的代码直接吸纳进应用自己的 JS 文件中。
- **部署（Deploy）**：**分享包不需要部署。** 只有业务应用（App/Admin）构建出的 `dist` 需要部署。它们在生产环境下是**完全独立、自包含**的。

---

## 阶段二：深入——面对“源码同步”与“版本隔离”的矛盾

### ❓ 困惑：同一个仓库下，隔离有意义吗？

> “既然都在一个 Git 仓库下，改了共享包所有应用都会立即变，那‘独立版本’还有什么意义？如果我有 10 个项目，我只想给其中 1 个升级 `shared`，另外 9 个不动以避免测试风险，能做到吗？”

### 💡 逻辑碰撞：物理锁与逻辑标签

- **物理现实**：在 Monorepo 模式 A（纯源码模式）中，改了文件夹，所有 App 看到的都是最新的。**无法在本地开发时让一个 App 用旧文件夹，另一个用新文件夹。**
- **版本号的尊严**：
  - **如果不发布 NPM**：版本号主要用于 **发布追踪 (Changelog)** 和 **CI/CD 触发逻辑**。
  - **如果需要物理隔离**：必须建立 **私有 NPM 仓库**。发布时，App-Admin 升级依赖号到 `1.1.0`（从仓库下新包），而其他 App 锁定在 `1.0.0`（从仓库下旧包）。这是实现“择机更新”的唯一通路。

---

## 阶段三：工具——Turborepo 的真正威力

### ❓ 困惑：有了 Turborepo 还需要 Changesets 吗？

> “Turborepo 到底解决了什么？它的缓存能像版本号一样锁定代码吗？”

### 💡 边界理清：执行引擎 vs 流程管理

- **Turborepo**：技术层面的“跑腿工”。它负责**任务编排**（先打哪个包）和**构建缓存**。
  - _修正_：它不能锁定旧代码。只要源码一变，缓存失效，强制更新。
- **Changesets**：流程层面的“记账员”。它负责管理版本号的跳变和 Changelog 的生成。

---

## 阶段四：选型——中小团队的极致性价比

### 🎯 最终共识：全量同步 vs 独立升级

通过交流，我们明确了两种路径的权衡：

1.  **模式 A：全量同步（One Version Rule）** —— **最推荐**
    - **逻辑**：改一处，测全部。强迫底层代码保持高内聚。
    - **保障**：不靠版本号，靠 **自动化单元测试**。只要 `shared` 单元测试通过，就信任它对其他应用的兼容性。

2.  **模式 B：私有 NPM 隔离** —— **大型团队选型**
    - **逻辑**：通过私有服务器托管不同版本的压缩包。
    - **代价**：增加了发布成本和调试链路，但赢得了发布节奏的绝对自由。

---

## 阶段五：深度依赖——Peer Dependencies 机制

### ❓ 困惑：为什么共享包里不直接安装 Vue？

> “既然共享包需要使用 Vue 的 API，为什么不直接把它装在 dependencies 里？那样应用不也省事吗？”

### 💡 核心逻辑：单例模式与法律约束

- **物理本质**：在现代前端架构中，`vue`、`react`、`vant` 等库通常必须是**单例**。
- **风险**：如果 `shared` 自带一个 Vue，应用项目也带一个 Vue，打包时会出现两套运行时，导致全局指令失效、状态不共享。
- **Peer Dependencies 的作用**：
  1.  **约束**：声明“大佬（应用项目）你必须自备 Vue”。
  2.  **去重**：确保构建时整棵树只有一个 Vue 实例，减少体积，规避冲突。
- **本项目配置**：
  - 我们在 `@myorg/shared` 的 `peerDependencies` 中声明了 `vue` 和 `vant`。
  - 同时在 `devDependencies` 中也装了一份，仅用于开发时提供类型提示。

---

## 阶段六：进阶工具——Turbo 与 Changesets 实战

### 1. Turborepo (构建引擎)

- **核心配置**：`turbo.json` 定义了 `build` 依赖于 `^build`（上游依赖先行）。
- **常用命令**：
  - `pnpm build`: 全量极速构建（带缓存）。
  - `pnpm dev:app`: 仅启动特定应用的开发环境。
- **价值**：任务并行执行，第二次构建“零秒完成”（缓存机制）。

### 2. Changesets (版本专家)

- **工作流**：
  1.  `pnpm change`: 交互式记录代码变更。
  2.  `pnpm version`: 消耗记录，自动计算并更新受影响包的版本号。
  3.  `.changeset/*.md`: 存放待处理的变更记录，建议随代码一起提交 Git。
- **价值**：实现 Monorepo 内精准的语义化版本控制。

---

## 阶段七：精简之道——pnpm Catalogs 机制

### ❓ 困惑：为什么升级一个依赖要改几十个 package.json？

> “手动同步所有子包的版本太痛苦了，而且 Git 变更里全是重复的数字，有没有更优雅的办法？”

### 💡 核心逻辑：中央仓库 (Dependency Source of Truth)

- **物理本质**：在 `pnpm-workspace.yaml` 中定义 `catalog` 字段，作为全仓库的“版本真理”。
- **优势**：
  1.  **极简配置**：子包中使用 `"vue": "catalog:"`，无需写版本号。
  2.  **一键升级**：修改一个 YAML 文件，全仓库同步更新，且不产生任何 `package.json` 的 Git 噪音。
  3.  **安全可靠**：强制全仓库使用同一个版本的 Vue/Vite，彻底消除“版本碎片化”导致的神秘 Bug。

---

## 💡 结语

Monorepo 不仅仅是一种代码组织方式，更是一种**团队协作文化**。它鼓励共享，同时通过现代化的工具（pnpm, Vite, Turborepo）来解决共享带来的体积和构建效率问题。
